<!DOCTYPE html>
<html>


<head>
    <meta charset="utf-8">

    <!-- mathbox -->
    <script src="../lib/mathbox/build/mathbox-bundle.js"></script>
    <link rel="stylesheet" href="../lib/mathbox/build/mathbox.css">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1">

    <!--math-->
    <script src="../lib/math.min.js"></script>

    <!--jquery-->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>


    <!--bootstrap-->
    <link rel="stylesheet" src="../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css">
    <link rel="stylesheet" src="../lib/bootstrap-3.3.7-dist/css/bootstrap-theme.min.css">
    <script src="../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js"></script>

    <!--
    bootstrap toggle
<link href="https://gitcdn.github.io/bootstrap-toggle/2.2.2/css/bootstrap-toggle.min.css" rel="stylesheet">
<script src="https://gitcdn.github.io/bootstrap-toggle/2.2.2/js/bootstrap-toggle.min.js"></script>
-->

    <link href="../lib/switch/css/bootstrap3/bootstrap-switch.min.css" rel="stylesheet">
    <script src="../lib/switch/js/bootstrap-switch.min.js"></script>



    <!--bootstrap slider-->
    <link href="../lib/slider/bootstrap-slider.min.css" rel="stylesheet">
    <script src="../lib/slider/bootstrap-slider.min.js"></script>

    <!-- my css -->
    <link href="../lib/css/mystyle.css" rel="stylesheet">

</head>




<body style="height: 500px; background:#f8f8f8;">


    <table class="panel" style="margin-left: auto;
margin-right: auto; width:80%">
        <tr>
            <th class="labels" style="color:#0fbfcf">
                <label class="sliderlabel">Glue Latitudinal Edge</label>
            </th>
            <th>
                <input id="slidera" data-slider-id='ex1Slider' type="text" data-slider-min="0" data-slider-max="1" data-slider-step="0.01" data-slider-value="0.0" data-slider-tooltip='hide' />
            </th>

        </tr>
        <tr>
            <th class="labels" style="color:#0fbfcf">
                <label class="sliderlabel">Glue Longitudinal Edge</label>
            </th>
            <th>
                <input id="sliderb" data-slider-id='ex1Slider' type="text" data-slider-min="0" data-slider-max="1" data-slider-step="0.01" data-slider-value="0.0" data-slider-tooltip='hide' />
            </th>


        </tr>
        <!--Knot Curve Toggle-->
        <tr>
            <th class="labels" style="color:#0fbfcf">
                <label class="sliderlabel">Knot Curve</label>
            </th>
            <th>
                <input id="knottoggle" type="checkbox" checked data-toggle="toggle" value="1.0" onchange="togfun(this);" data-onstyle="primary">
            </th>
        </tr>
        <!--Blue Piecewise Toggle-->
        <tr>
            <th class="labels" style="color:#0fbfcf">
                <label class="sliderlabel">Blue Boundary</label>
            </th>
            <th>
                <input id="bluetoggle" type="checkbox" data-toggle="toggle" value="1.0" onchange="bluetogfun(this);" data-onstyle="primary">
            </th>
        </tr>

        <!--Red Piecewise Toggle-->
        <tr>
            <th class="labels" style="color:#0fbfcf">
                <label class="sliderlabel">Orange Boundary</label>
            </th>
            <th>
                <input id="redtoggle" type="checkbox" data-toggle="toggle" value="1.0" onchange="redtogfun(this);" data-onstyle="primary">
            </th>
        </tr>

        <!--            Time Slider-->
        <th class="labels" style="color:#0fbfcf">
            <label class="sliderlabel">Time</label>
        </th>
        <th>
            <input id="slidertime" data-slider-id='ex1Slider' type="text" data-slider-min="0" data-slider-max="6.28" data-slider-step="0.01" data-slider-value="4.7" data-slider-tooltip='hide' />
        </th>
    </table>


    <script>
        //Slider Script
        $('#slidera').slider({
            formatter: function(value) {
                return 'Current value: ' + value;
            }
        });

        $('#sliderb').slider({
            formatter: function(value) {
                return 'Current value: ' + value;
            }
        });

        $('#slidertime').slider({
            formatter: function(value) {
                return 'Current value: ' + value;
            }
        });

        //        $('#slider').on('slide', slidefunction)



        //        function slidefunction() {
        //
        //            var sliderval = Number($('#slider').val());
        //
        //            mathbox.select('surface').set('opacity', sliderval);
        //            console.log(typeof sliderval)
        //        }

        //Button SCript
        //BlueToggle
        $('#bluetoggle').bootstrapSwitch({
            size: 'small',
            offColor: 'danger',
        });

        function bluetogfun(button) {
            var butprop = $('#bluetoggle').prop('checked');
            var butval = $('#bluetoggle').val();
            if (butprop == true) {
                $('#bluetoggle').val(1.0);
                mathbox.select('#blueboundary')[0].set('visible', true)
            } else {
                $('#bluetoggle').val();
                mathbox.select('#blueboundary')[0].set('visible', false)
            }

        }
        //RedToggle
        $('#redtoggle').bootstrapSwitch({
            size: 'small',
            offColor: 'danger',
        });

        function redtogfun(button) {
            var butprop = $('#redtoggle').prop('checked');
            var butval = $('#redtoggle').val();
            if (butprop == true) {
                $('#redtoggle').val(1.0);
                mathbox.select('#redboundary')[0].set('visible', true)
            } else {
                $('#redtoggle').val();
                mathbox.select('#redboundary')[0].set('visible', false)
            }

        }

        //KnotToggle
        $('#knottoggle').bootstrapSwitch({
            size: 'small',
            offColor: 'danger',
        });

        function togfun(button) {
            var butprop = $('#knottoggle').prop('checked');
            var butval = $('#knottoggle').val();
            if (butprop == true) {
                $('#knottoggle').val(1.0);
                mathbox.select('#knotcurve')[0].set('visible', true)
            } else {
                $('#knottoggle').val();
                mathbox.select('#knotcurve')[0].set('visible', false)
            }

        }

    </script>


    <script>
        var mathbox = mathBox({
            plugins: ['core', 'controls', 'cursor'],
            controls: {
                // Orbit controls, i.e. Euler angles, with gimbal lock
                klass: THREE.OrbitControls,
                parameters: {
                    noZoom: true
                },

                // Trackball controls, i.e. Free quaternion rotation
                //klass: THREE.TrackballControls,
            },
            mathbox: {
                warmup: 1
            }
        });
        if (mathbox.fallback) throw "WebGL not supported"

        var three = mathbox.three;
        three.renderer.setClearColor(new THREE.Color('#f8f8f8'), 1.0);

        var time = three.Time.clock;

        // Place camera
        var camera =
            mathbox
            .camera({
                proxy: true,
                position: [0, 0, 3],
                lookAt: [0, 0, 0]

            });



        // 2D cartesian
        var view =
            mathbox
            .cartesian({
                position: [0, 0, -0.33],
                range: [
                    [-math.pi, math.pi],
                    [-math.pi, math.pi],
                    [-math.pi, math.pi]
                ],
                scale: [1, 1, 1],
            });


        var alpha = 2;

        //Quality of Life
        var pi = math.pi;
        var sin = math.sin;
        var cos = math.cos;

        function torus(x, y) {
            R = 2;
            r = 1;

            var a = Number($('#slidera').val())
            var b = Number($('#sliderb').val())

            // return [(R-r*cos(x*b))*((1-a)*y+sin(a*y)),(R-r*cos(b*x))*-cos(a*y),(1-b)*x + r*sin(b*x)]

            return [
                (R - r * ((1 - a) + a * cos(x * b))) * ((1 - a) * y + sin(a * y)), (1 - b) * x + r * sin(b * x), (R - r * cos(b * x)) * -cos(a * y) + 1
            ]

        }


        view.area({
            id: 'densearea',
            width: 100,
            height: 100,
            // axes: [1, 3],
            expr: function(emit, x, y, i, j, time) {
                emit(...torus(x, y));

            },
            items: 1,
            channels: 3,
        });

        view.surface({
            shaded: false,
            color: '#0FBFCF',
            opacity: 0.0,

        });

        view.area({
            id: 'sparsearea',
            width: 64,
            height: 10,
            // axes: [1, 3],
            expr: function(emit, x, y, i, j, time) {
                emit(...torus(x, y));
                emit(...torus(y, x));
            },
            items: 2,
            channels: 3,
        });

        view.resample({
            id: 'sparsesample',
            source: mathbox.select('#densearea')[1],
            width: 64,
            height: 10
        })

        view.line({
            points: mathbox.select('#sparsesample')[1],
            color: '#0FBFCF',
            zBias: 1,
            opacity:0.1
        })

        //                //Edges of Torus
        //                view.interval({
        //                    id: 'redline',
        //                    width: 64,
        //                    expr: function(emit, x, i, time) {
        //                        emit(...torus(x, -pi));
        //                        emit(...torus(x, pi));
        //                    },
        //                    items: 2,
        //                    channels: 3,
        //                })
        //        
        //                view.line({
        //                    points: mathbox.select('#redline')[1],
        //                    color: '#FF4136',
        //                    zBias: 12
        //                })
        //        
        //        
        //                view.interval({
        //                    id: 'yellowline',
        //                    width: 64,
        //                    expr: function(emit, y, i, time) {
        //                        emit(...torus(-pi, y));
        //                        emit(...torus(pi, y));
        //                    },
        //                    items: 2,
        //                    channels: 3,
        //                })
        //        
        //                view.line({
        //                    points: mathbox.select('#yellowline')[1],
        //                    color: '#FFDC00',
        //                    zBias: 13
        //                })

        // Torus Knot Parameters
        var p = 3;
        var q = 2;
        var m = p / q;
        var m2 = q / p;
        var eps = 0.01;


        function mod2pi(x) {
            return (x % (2 * pi) + 2 * pi) % (2 * pi)
        }




        // Knot Curve
        function knot(x) {
            return (m2 * x) % (2 * pi);
        }

        view.interval({
            range: [0, 2 * p * pi],
            expr: function(emit, x, i, t) {
                //-(pi,pi,0) needed for new bounds
                emit(...torus(x % (2 * pi) - pi, knot(x) - pi));
            },
            width: 400,
            channels: 3,
        });
        view.line({
            id: 'knotcurve',
            color: 'green',
            visible: true,
            proximity: 1,
            blending: 'no',
            zBias: 14
        })



        //        // Knot Traveller
        //
        //        function sphere(r, th, ph, x, y, z) {
        //            return [r * cos(th) * sin(ph) + x, r * sin(th) * sin(ph) + y, r * cos(ph) + z]
        //        }
        //        view.area({
        //            id: 'spherearea',
        //            width: 100,
        //            height: 100,
        //            // axes: [1, 3],
        //            expr: function(emit, x, y, i, j, time) {
        //                var t = time
        //                var [X, Y, Z] = torus(t % (2 * pi) - pi, knot(t) - pi);
        //                emit(...sphere(0.1, x, y, X, Y, Z));
        //
        //            },
        //            items: 1,
        //            channels: 3,
        //
        //        });
        //
        //        view.surface({
        //            id: 'knottraveller',
        //            shaded: false,
        //            color: 'green'
        //
        //        });



        //Piecewise Stuff
        //        //First Piecewise Curve
        //        function piecewise(x, n) {
        //            //Triangle Wave Function to match knot + rungs!
        //            x = x % (2 * pi);
        //            var period = (pi) / q;
        //            var amplitude = pi / (2 * p);
        //            var wave = ((2 * amplitude) / pi) * math.asin(sin(x * pi / period)) + 2 * pi * n / p
        //
        //            return mod2pi(wave)
        //        }
        //        


        function modpi(x) {
            //Function for Modular Arithmetic on [-pi,pi]
            return ((x + 2 * pi) % (2 * pi) - pi)
        }

        
                function surfacecut(x){
            var X=x
            var thresh = 0.02;
            
            if(Math.abs(pi)-X<thresh){
                 X=NaN
            }

            return X
        }
        
        function fakemodpi(x) {
            var tpi = 2 * pi;
            var X = x;

            //To stop edge errors:


            while (Math.abs(X) > pi) {
                if (X <= -pi) {
                    X = X + 2 * pi
                } else if (X >= -pi + tpi) {
                    X = X - tpi
                }
            }

            return surfacecut(X)
        }
        


        function truemodpi(x) {
            return (x + pi) % (2 * pi) - pi
        }
        console.log(fakemodpi(0))
        console.log(fakemodpi(pi + 0.1))

        //((2*amplitude)/pi)*math.asin(sin((x+t/q)*pi/period))+2*pi*n/p-(1/p)*t
        //First Piecewise Curve
        function piecewise(x, n) {
            //Triangle Wave Function to match knot + rungs!
            x = x % (2 * pi);
            var t = Number($('#slidertime').val());
            var period = (pi) / q;
            var amplitude = pi / (2 * p);
            var wave = ((2 * amplitude) / pi) * math.asin(sin((x + t / q) * pi / period)) + 2 * pi * n / p - (t / p)

            return fakemodpi(wave - pi / p)
        }


        view.interval({
            range: [0, 4 * pi],
            expr: function(emit, x, i, t) {
                //(0,-pi,0) shift to match new domains
                emit(...torus(fakemodpi(x)+eps , surfacecut(piecewise(x, 0))));
                emit(...torus(fakemodpi(x) + eps, surfacecut(piecewise(x, 1))));
                emit(...torus(fakemodpi(x) + eps, surfacecut(piecewise(x, 2))));
            },
            width: 1000,
            channels: 3,
            items: 3

        });
        view.line({
            id: 'blueboundary',
            color: '#49a7e9',
            visible: false,
            zBias: 15,
            proximity: 0.5
        });




        //Second Piecewise Curve
        function piecewise2(x, n) {
            x = x % (2 * pi);
            var t = Number($('#slidertime').val());
            var period = (pi) / p;
            var amplitude = pi / (2 * q);
            var wave = ((2 * amplitude) / pi) * math.asin(sin((x - t / p) * pi / period)) - 2 * pi * n / q
                //    var wave = ((2 * amplitude) / pi) * math.asin(sin((x+ t / q) * pi / period)) + 2 * pi * n / p - (t / p)

            return fakemodpi(-(wave - pi / q + (1 / q) * t))
        }


        view.interval({

            expr: function(emit, x, i, t) {
                emit(...torus(surfacecut(piecewise2(x, 0) - eps), -fakemodpi(x)));
                emit(...torus(surfacecut(piecewise2(x, 1) - eps), -fakemodpi(x)));
            },
            width: 600,
            channels: 3,
            items: 2

        });
        view.line({
            id: 'redboundary',
            color: '#fab125',
            proximity: 1,
            visible: false,
            zBias: 15
        });

        function SurfaceCut(x) {
            if (x <= 0) {
                x = NaN;
            } else if (x >= 2 * pi) {
                x = NaN;
            }
            return x
        }



//        //First Piecewise Curve
//            function piecewise(x,t,n){
//             
//              x= x%(2*pi);
//              var period = (pi)/q;
//              var amplitude = pi/(2*p);
//              var wave = ((2*amplitude)/pi)*math.asin(sin((x+t/q)*pi/period))+2*pi*n/p-(1/p)*t
//        
//        
//              return fakemodpi(wave)
//            }
//        
//        
//            view.area({
//        
//              expr: function(emit,x,y,i,j,t){
//        
//                  var tau =  Number($('#slidertime').val());
//        
//                  var xdom = SurfaceCut(x);
//        
//        
//                  emit(xdom, piecewise(x,tau,-1),-y);
//                  emit(xdom, piecewise(x,tau,0),-y);
//                  emit(xdom, piecewise(x,tau,1),-y);
//                  emit(xdom, piecewise(x,tau,2),-y);
//                 },
//                 rangeX:[0,3*pi],
//                 rangeY:[0,pi/4],
//                 width:164,
//                 height:164,
//                 channels:3,
//                 items:4,
//
//        
//            });
//            view.surface({
//              color:'#0074D9',
//              proximity:10000000000,
//              shaded:true,
//              crossed:true,
//                                zBias:1,
//        
//        
//            });

        mathbox.set('focus', 2);

    </script>



</body>

</html>
